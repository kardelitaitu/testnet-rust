# Tasks Directory

This directory contains the task implementations (`tXX_taskname.rs`) and their corresponding documentation (`tXX.md`).

## üõ†Ô∏è Developer Guidelines

1.  **Do Not Break Existing Tasks**: Ensure changes in shared logic (like `core-logic` or `utils`) do not break other tasks. Run `cargo check` frequently.
2.  **Fire and Forget**: Tasks should generally not block on transaction confirmation. Once the transaction hash is obtained (entered mempool), return success.
3.  **Documentation**: Every `.rs` implementation must have a matching `.md` file explaining the workflow, inputs, and expected outputs.
4.  **Zero Warnings**: When a task is marked as complete, ensure it compiles and runs with **zero warnings**. Clean up unused imports and variables.
5.  **Update Task MD**: Upon task completion, update the corresponding `tXX.md` file to reflect the final implementation details and accurate debugging instructions.

## üêõ Debugging

To run a specific task isolated from the spammer swarm:

```bash
# Syntax: cargo run --bin debug_task -- --task <ID> --wallet <INDEX>
cargo run --bin debug_task -- --task 1 --wallet 0
```

## ü™ô Token Types

The Tempo environment interacts with three primary categories of tokens:

1.  **System Tokens**: Pre-deployed stablecoins managed by the network configuration. Used for base pairs and initial testing.
2.  **Created Stablecoins**: New stablecoins deployed dynamically by **Task 04**. These simulate user-created pegged assets.
3.  **Created Memecoins**: Speculative tokens deployed dynamically by **Task 21**. Used for high-volume transfer and swap testing.

## üèõÔ∏è System Tokens

The following tokens are hardcoded into the pre-genesis state and are always available:

| Name     | Symbol     | Address                                      |
| :---     | :---       | :---                                         |
| PathUSD  | `PathUSD`  | `0x20C0000000000000000000000000000000000000` |
| AlphaUSD | `AlphaUSD` | `0x20c0000000000000000000000000000000000001` |
| BetaUSD  | `BetaUSD`  | `0x20c0000000000000000000000000000000000002` |
| ThetaUSD | `ThetaUSD` | `0x20c0000000000000000000000000000000000003` |

## üìö References

When developing a new task or porting logic, refer to these resources:

*   **Logic Implementation**: `chains/tempo/_reference-nodejs DONOT USE THIS FOLDER`
    *   Contains the original Node.js scripts. Use this as the **primary source of truth** for task logic (inputs, outputs, steps).
*   **Context & Docs**: `chains/tempo/docs`
    *   Contains general documentation about the Tempo chain and environment.

## üìÇ Tempo Folder Structure

Understanding the layout of `chains/tempo/src` helps in finding reusable components:

*   **`bin/`**: Entry points for binaries.
    *   `tempo-project.rs`: The main Spammer Swarm application.
    *   `debug_task.rs`: The interactive debugger CLI.
*   **`tasks/`**: Individual task implementations (`tXX_name.rs`) and their documentation (`tXX.md`).
*   **`utils/`**: Shared helper modules.
    *   `contract_compiler.rs`: Compiles Solidity contracts on the fly.
    *   `gas_manager.rs`: Handles gas estimation and priority fees.
    *   `multicall.rs`: Helper for batching calls via Multicall3.
    *   `nonce_manager.rs`: Manages transaction nonces locally.
    *   `address_reader.rs`: Random address selection from `address.txt`.

## üöÄ Transaction Batching Methods (5 Total)

The framework supports **5 batching strategies** - 3 standard EVM patterns (implemented) and 2 Tempo-specific features (planned).

### Legend
- ‚úÖ = Implemented in current codebase
- ‚ùå = Not implemented (requires primitives crate integration)

---

### 1. Multicall3 Aggregation (‚úÖ Implemented)

**Best for**: ERC20 token transfers to many recipients (gas efficient)

**How it works**: Uses the canonical Multicall3 contract (`0xcA11bde05977b3631167028862bE2a173976CA11`) to bundle multiple calls into a single transaction.

```rust
// 1. Approve token for multicall
token.approve(multicall_addr, U256::max_value()).send().await?;

// 2. Build call array
for recipient in recipients {
    let data = token.encode("transferFrom", (wallet_addr, recipient, amount))?;
    calls.push(Call { target: token_addr, call_data: data });
}

// 3. Single transaction executes all
multicall.aggregate(calls).gas_price(bumped_gas_price).send().await?;
```

**Tasks using this**: Task 28 (System), 29 (Stable), 30 (Meme) - "Disperse" tasks

| Pros | Cons |
|------|------|
| Single nonce required | Requires ERC20 approval |
| Gas efficient (one base fee) | Fails atomically if one call reverts |
| Fast confirmation | Can't batch native ETH transfers |

---

### 2. Concurrent Async Sending (‚úÖ Implemented)

**Best for**: High-volume native ETH transfers

**How it works**: Sends multiple transactions in parallel using Tokio futures. Provider handles nonce management automatically.

```rust
let mut futures = vec![];
for recipient in recipients {
    let tx = TransactionRequest::new()
        .to(recipient)
        .value(amount)
        .gas_price(bumped_gas_price);
    futures.push(client.send_transaction(tx, None)); // Fire async
}

for pending in futures {
    match pending.await {
        Ok(p) => { /* collect receipts */ }
        Err(e) => println!("Tx failed: {:?}", e),
    }
}
```

**Tasks using this**: Task 31 (System), 32 (Stable), 33 (Meme) - "Concurrent" tasks

| Pros | Cons |
|------|------|
| No approvals needed | Multiple nonces consumed |
| Works for native ETH | Higher total gas (separate base fees) |
| Very fast execution | No atomicity |

---

### 3. Sequential Loop (‚úÖ Implemented)

**Best for**: Critical operations requiring ordering and reliability

**How it works**: Simple for-loop sending one transaction at a time, waiting for each receipt before sending the next.

```rust
for recipient in recipients {
    let tx = token.transfer(recipient, amount).gas_price(bumped_gas_price);
    let pending = tx.send().await?;
    let receipt = pending.await?;
}
```

**Tasks using this**: Task 25, 26, 27, 34, 35, 36, 43, 44 - "Batch" and "Mint" tasks

| Pros | Cons |
|------|------|
| Guaranteed ordering | Slowest (waits for confirmations) |
| Easy per-tx error handling | Multiple nonces |
| Works with any token type | Higher latency |

---

### 4. Tempo 2D Nonce System (‚ùå Not Implemented - Requires Primitives Crate)

**Best for**: High-throughput parallel payments without waiting for confirmations

**How it works**: Tempo uses a **2D nonce system** that enables true parallel transaction execution:

- **`nonceKey: 0`** = Protocol nonce (sequential, like standard EVM)
- **`nonceKey: 1+`** = User nonces (independent parallel sequences)

```rust
// Send 3 transactions in PARALLEL using different nonce keys
// Each key maintains its own independent nonce sequence
let tx1 = token.transfer(recipient1, amount).nonce_key(1);
let tx2 = token.transfer(recipient2, amount).nonce_key(2);
let tx3 = token.transfer(recipient3, amount).nonce_key(3);

// Execute all in parallel - no waiting for confirmations!
let hashes = futures::future::join_all([tx1, tx2, tx3]).await;
```

**Reference**: [Tempo Parallel Transactions Guide](docs/guide/payments/send-parallel-transactions.mdx)

| Pros | Cons |
|------|------|
| True parallel execution | Requires primitives crate |
| No waiting for confirmations | More complex nonce tracking |
| Maximum throughput | Higher gas (key provisioning) |

**Nonce Key Strategies**:
- **Explicit keys** (1n, 2n, etc.): Reusable, more gas-efficient
- **'random' keys**: Auto-generate unique keys for bursts

**Status**: The `nonce_manager_2d.rs` module exists but is not fully integrated into task workflows.

---

### 5. Tempo Native Batch Transactions (‚úÖ Implemented - Task 4 Uses It!)

**Best for**: Atomic multi-operation transactions

**How it works**: Batching built directly into `TempoTransaction` type at protocol level - no smart contract required.

**Implementation**: `chains/tempo/src/utils/tempo_tx.rs` and `tempo_tx_sender.rs`

```rust
// Native batch - single transaction, multiple calls atomically
let batch_sender = TempoBatchSender::new(provider, wallet);

let calls = vec![
    TempoCall { to: token_addr, value: 0, input: grant_calldata },
    TempoCall { to: token_addr, value: 0, input: mint_calldata },
];

let receipt = batch_sender.send_batch(calls, nonce).await?;
```

**Used in**: Task 04 (Create Stable) - batches grant + mint operations

| Pros | Cons |
|------|------|
| Atomic execution (all or nothing) | Single transaction failure point |
| Single signature for batch | Fixed gas overhead per call |
| No ERC20 approval needed | Not ideal for independent payments |
| Cheaper than Multicall3 | |

**Reference**: [Tempo Batch Transactions Guide](docs/guide/use-accounts/batch-transactions.mdx)

---

### Quick Comparison

| # | Method | Gas | Speed | Atomicity | Implemented | Tempo-Unique |
|---|--------|-----|-------|-----------|-------------|--------------|
| 1 | Multicall3 | High | Fast | Partial | ‚úÖ | ‚ùå |
| 2 | Concurrent Async | Medium | Very Fast | None | ‚úÖ | ‚ùå |
| 3 | Sequential Loop | Low | Slow | Full | ‚úÖ | ‚ùå |
| 4 | Tempo 2D Nonces | Medium | ‚ö° Max | None | ‚ùå | ‚úÖ YES |
| 5 | Tempo Native Batch | High | Fast | Full | ‚úÖ | ‚úÖ YES |

---

### When to Use Which

| Use Case | Recommended Method |
|----------|-------------------|
| ERC20 batch transfers to many | Multicall3 (1) |
| Native ETH distribution | Concurrent Async (2) |
| Critical ordered operations | Sequential Loop (3) |
| High-throughput parallel payments | Tempo 2D Nonces (4) ‚ö†Ô∏è |
| Atomic multi-step operations | Tempo Native Batch (5) ‚ö†Ô∏è |
