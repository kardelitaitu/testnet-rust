# JSON Wallet Specification

This document outlines the specification for the protected JSON wallet files used in the Wallet Manager application. It details the file format, encryption standards, and the structure of the decrypted data.

## 1. File Format

Wallet files are stored as JSON files (e.g., `0001.json`). The root object contains metadata about the encryption method and the encrypted payload.

```json
{
  "encryption_type": "aes-256-gcm",
  "encrypted": {
    "ciphertext": "<hex_string>",
    "iv": "<hex_string>",
    "salt": "<hex_string>",
    "tag": "<hex_string>",
    "encryption_type": "aes-256-gcm"
  }
}
```

## 2. Encryption Specification

The application uses **AES-256-GCM** (Galois/Counter Mode) for authenticated encryption.

### Key Derivation
The encryption key is derived from the user's password using **scrypt**.

*   **Algorithm**: `scrypt`
*   **Password**: User-provided password (UTF-8 string).
*   **Salt**: 16 bytes (randomly generated for each file), stored in `encrypted.salt` as a hex string.
*   **Key Length**: 32 bytes (256 bits).
*   **Cost Parameters**: Default Node.js `crypto.scryptSync` defaults (N=16384, r=8, p=1).

### Encryption Parameters
*   **Algorithm**: `aes-256-gcm`
*   **Key**: Derived via scrypt (32 bytes).
*   **IV (Initialization Vector)**: 12 bytes (randomly generated), stored in `encrypted.iv` as a hex string.
*   **Auth Tag**: 16 bytes (generated by GCM), stored in `encrypted.tag` as a hex string.
*   **Ciphertext**: The encrypted data, stored in `encrypted.ciphertext` as a hex string.

## 3. Decryption Logic

To decrypt the wallet data, follow these steps:

1.  **Read and Parse**: Read the JSON file and parse the `encrypted` object.
2.  **Decode Hex**: Convert the hex strings for `salt`, `iv`, `tag`, and `ciphertext` back into binary buffers.
3.  **Derive Key**:
    ```javascript
    key = scrypt(password, salt, 32_bytes)
    ```
4.  **Initialize Decipher**:
    Create an AES-256-GCM decipher instance using the derived `key` and the extracted `iv`.
5.  **Set Auth Tag**: Set the authentication tag to the extracted `tag`.
6.  **Decrypt**:
    *   Update the decipher with the `ciphertext`.
    *   Finalize the decryption.
    *   *Note*: If the password is incorrect or data is tampered with, the GCM tag verification will fail.
7.  **Parse Payload**: The resulting plaintext is a UTF-8 JSON string. Parse it to obtain the wallet data.

## 4. Decrypted Payload Structure

The decrypted content is a JSON object containing private keys, addresses, and the mnemonic phrase for multiple blockchain networks.

```json
{
  "mnemonic": "word1 word2 word3 ... word12",
  
  "evm_private_key": "0x...",
  "evm_address": "0x...",
  
  "sol_private_key": "<hex_string>",
  "sol_address": "<base58_string>",
  
  "sui_private_key": "<base64_or_hex_string>",
  "sui_address": "0x...",
  
  "tron_private_key": "<hex_string>",
  "tron_address": "T...",
  
  "aptos_private_key": "<hex_string>",
  "aptos_address": "0x...",
  
  "ton_private_key": "<hex_string>",
  "ton_address": "EQ..."
}
```

### Field Descriptions
*   **mnemonic**: The 12-word BIP39 recovery phrase.
*   **evm_***: Ethereum Virtual Machine (Ethereum, BSC, Polygon, etc.) credentials.
*   **sol_***: Solana network credentials.
*   **sui_***: Sui network credentials.
*   **tron_***: TRON network credentials.
*   **aptos_***: Aptos network credentials.
*   **ton_***: The Open Network (TON) credentials.

## 5. Required Modules

### For Decryption
The **decryption** process itself relies entirely on the built-in Node.js **`crypto`** module. No external npm packages are strictly required just to decrypt the JSON file.

### For Wallet Operations (Optional)
If you intend to **use** the decrypted data (e.g., to re-derive keys from the mnemonic or validate addresses), you will need the following packages which are used in this project:

```bash
npm install bip39 ethers @solana/web3.js @mysten/sui.js @ton/ton @ton/crypto js-sha3 ed25519-hd-key
```
